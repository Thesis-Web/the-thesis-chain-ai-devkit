// TARGET: aidev src/runners/github-runner.ts

/*
  GitHub Runner (Architecture Skeleton)

  This file models how a GitHub App or webhook-driven service would:
  - verify webhook signatures
  - fetch PR files (diff-limited)
  - apply policy (allow/deny paths)
  - run agent pipeline
  - post advisory comments/check runs

  Public skeleton: no network calls; all I/O functions are stubs.
*/

import type { AgentContext, FileBlob, Report } from "../core/types";
import { isAllowedPath, DefaultPolicy } from "../core/policy";
import { runSpecLint } from "../agents/spec-lint.agent";
import { runPRSynthesis } from "../agents/pr-synthesis.agent";

export type WebhookEvent =
  | { type: "ping"; headers: Record<string, string>; bodyRaw: string; payload: any }
  | {
      type: "pull_request";
      action: "opened" | "synchronize" | "reopened";
      headers: Record<string, string>;
      bodyRaw: string;
      payload: any;
    };

export async function handleWebhook(evt: WebhookEvent): Promise<void> {
  // 1) Verify webhook signature (deterministic gate)
  verifyWebhookSignature(evt.headers, evt.bodyRaw);

  if (evt.type === "ping") return;
  if (evt.type !== "pull_request") return;

  // 2) Extract PR details
  const pr = extractPR(evt.payload);

  // 3) Mint installation token (GitHub App) or use workflow token
  const token = await mintInstallationToken(evt.payload.installation?.id);

  // 4) Fetch changed files (diff-limited) and filter by policy
  const files = await fetchPRFiles(pr, token);
  const eligible = files.filter((f) => isAllowedPath(f.path, DefaultPolicy));

  const ctx: AgentContext = {
    repo: { owner: pr.owner, name: pr.repo },
    pr: { number: pr.number, headSha: pr.headSha },
    diffSummary: pr.diffSummary,
    changedFiles: eligible,
    promptVersion: "1.0.0",
  };

  // 5) Run pipeline (advisory)
  const reports = await runPipeline(ctx);

  // 6) Render and post PR comment
  const comment = renderPRComment(reports);
  await postPRComment(pr, token, comment);
}

async function runPipeline(ctx: AgentContext): Promise<Report[]> {
  // Deterministic checks could also run here (schema lint, link checks, etc.)
  const reports: Report[] = [];
  reports.push(await runSpecLint(ctx));
  reports.push(await runPRSynthesis(ctx));
  return reports;
}

function renderPRComment(reports: Report[]): string {
  const lines: string[] = [];
  lines.push("## AI Devkit Review (Advisory)");
  lines.push("");
  lines.push(
    "This comment was generated by an assistive pipeline with schema-gated outputs and safety guardrails."
  );
  lines.push("Deterministic checks remain authoritative; AI output is advisory.");
  lines.push("");

  for (const r of reports) {
    lines.push(`### ${r.agent} v${r.version}`);
    for (const f of r.findings) {
      lines.push(`- **${String(f.severity).toUpperCase()}** [${f.category}] ${f.claim}`);
    }
    lines.push("");
  }

  return lines.join("\n");
}

/* ------------------------------- GitHub I/O ------------------------------- */
/* Public skeleton: stubs only. */

function verifyWebhookSignature(_headers: Record<string, string>, _bodyRaw: string): void {
  // In production:
  // - compute HMAC SHA-256 using webhook secret
  // - compare to X-Hub-Signature-256
}

async function mintInstallationToken(_installationId?: number): Promise<string> {
  // In production:
  // - sign JWT with GitHub App private key
  // - call /app/installations/{id}/access_tokens
  return "installation_token_stub";
}

async function fetchPRFiles(
  _pr: { owner: string; repo: string; number: number },
  _token: string
): Promise<FileBlob[]> {
  // In production:
  // - list PR files
  // - fetch contents for each eligible path
  return [];
}

async function postPRComment(
  _pr: { owner: string; repo: string; number: number },
  _token: string,
  _body: string
): Promise<void> {}

function extractPR(_payload: any): any {
  // Minimal shape; real extraction depends on GitHub webhook payload.
  return { owner: "", repo: "", number: 0, headSha: "", diffSummary: "diff summary" };
}
